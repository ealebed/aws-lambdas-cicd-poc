name: JavaScript Lambda Deploy

on:
  workflow_call:
    inputs:
      lambda_path:
        required: true
        type: string
        description: 'Path to the Lambda function directory (e.g., lambdas/javascript/example-lambda)'
      lambda_name:
        required: true
        type: string
        description: 'Name of the Lambda function (folder name)'
      environment:
        required: true
        type: string
    secrets:
      AWS_ROLE_ARN:
        required: true

jobs:
  build-and-deploy:
    name: Build and Deploy JavaScript Lambda - ${{ inputs.lambda_name }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: ${{ inputs.environment }}
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Decide on tag
        id: set-tag
        run: |
          TIMESTAMP=$(date -u +'%Y.%m.%d-%H.%M')
          BRANCH="${{ github.event.inputs.branch || github.ref_name }}"
          if [[ "${BRANCH}" == "master" ]]; then
            echo "TAG=${TIMESTAMP}" >> $GITHUB_OUTPUT
          else
            echo "TAG=${TIMESTAMP}-SNAPSHOT" >> $GITHUB_OUTPUT
          fi

      - name: Login to AWS
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActionsSession-${{ inputs.environment }}-${{ inputs.lambda_name }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Determine ECR repository
        id: ecr-repo
        run: |
          ECR_REPO="lambda-${{ inputs.lambda_name }}-${{ inputs.environment }}"
          echo "repository=$ECR_REPO" >> $GITHUB_OUTPUT
          echo "registry=${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com" >> $GITHUB_OUTPUT

      - name: Ensure ECR repository exists
        run: |
          aws ecr describe-repositories --repository-names ${{ steps.ecr-repo.outputs.repository }} --region ${{ vars.AWS_REGION }} || \
          aws ecr create-repository --repository-name ${{ steps.ecr-repo.outputs.repository }} --region ${{ vars.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: docker/login-action@v3
        with:
          registry: ${{ steps.ecr-repo.outputs.registry }}
          ecr: auto

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '24'

      - name: Determine Docker platform
        id: docker-platform
        working-directory: ${{ inputs.lambda_path }}
        run: |
          # Map Lambda architecture to Docker platform
          # Read from config if exists, otherwise default to x86_64
          if [ -f lambda-config.yaml ]; then
            if ! command -v yq &> /dev/null; then
              wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
              chmod +x /usr/local/bin/yq
            fi
            ARCH=$(yq eval '.lambda.architectures // "x86_64"' lambda-config.yaml)
          else
            ARCH="x86_64"
          fi

          if [ "$ARCH" = "x86_64" ]; then
            PLATFORM="linux/amd64"
          elif [ "$ARCH" = "arm64" ]; then
            PLATFORM="linux/arm64"
          else
            echo "::error::Unsupported architecture: $ARCH. Use x86_64 or arm64"
            exit 1
          fi
          echo "platform=$PLATFORM" >> $GITHUB_OUTPUT
          echo "Building for platform: $PLATFORM"

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.lambda_path }}
          file: lambdas/javascript/Dockerfile
          push: true
          platforms: ${{ steps.docker-platform.outputs.platform }}
          # Disable provenance and SBOM to avoid multi-arch manifest issues with Lambda
          provenance: false
          sbom: false
          tags: |
            ${{ steps.ecr-repo.outputs.registry }}/${{ steps.ecr-repo.outputs.repository }}:${{ steps.set-tag.outputs.TAG }}
            ${{ steps.ecr-repo.outputs.registry }}/${{ steps.ecr-repo.outputs.repository }}:latest
          cache-from: type=registry,ref=${{ steps.ecr-repo.outputs.registry }}/${{ steps.ecr-repo.outputs.repository }}:buildcache
          cache-to: type=registry,ref=${{ steps.ecr-repo.outputs.registry }}/${{ steps.ecr-repo.outputs.repository }}:buildcache,mode=max

      - name: Capture image URI
        id: image-uri
        run: |
          echo "uri=${{ steps.ecr-repo.outputs.registry }}/${{ steps.ecr-repo.outputs.repository }}:${{ steps.set-tag.outputs.TAG }}" >> $GITHUB_OUTPUT

      - name: Parse Lambda configuration
        id: lambda-config
        run: |
          bash scripts/parse-lambda-config.sh "${{ inputs.lambda_path }}" "${{ inputs.lambda_name }}"

      - name: Build tags payload
        id: tags
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          REGION: ${{ vars.AWS_REGION }}
          VERSION: ${{ steps.set-tag.outputs.TAG }}
          LANGUAGE: javascript
          SERVICE: ${{ inputs.lambda_name }}
          CONFIG_TAGS: ${{ steps.lambda-config.outputs.config_tags }}
        run: |
          DEFAULT_TAGS=$(jq -n \
            --arg env "$ENVIRONMENT" \
            --arg region "$REGION" \
            --arg version "$VERSION" \
            --arg language "$LANGUAGE" \
            --arg service "$SERVICE" \
            '{Environment:$env, Region:$region, Version:$version, Language:$language, Service:$service}')

          # Parse CONFIG_TAGS, defaulting to {} if empty or invalid
          if [ -z "$CONFIG_TAGS" ] || [ "$CONFIG_TAGS" = "null" ]; then
            CONFIG_TAGS_JSON="{}"
          else
            # Validate and parse CONFIG_TAGS JSON
            CONFIG_TAGS_JSON=$(echo "$CONFIG_TAGS" | jq -c '.' 2>/dev/null || echo "{}")
          fi

          # Merge default tags with config tags
          MERGED=$(jq -c -s 'reduce .[] as $item ({}; . * $item)' <(echo "$DEFAULT_TAGS") <(echo "$CONFIG_TAGS_JSON"))
          echo "tags=$MERGED" >> $GITHUB_OUTPUT

      - name: Determine Lambda execution role ARN
        id: lambda-role
        run: |
          # Priority: lambda-config.yaml role_arn > LAMBDA_EXECUTION_ROLE_ARN secret > AWS_ROLE_ARN secret
          # Note: AWS_ROLE_ARN is the GitHub Actions OIDC role, which may not be suitable for Lambda execution
          if [ -n "${{ steps.lambda-config.outputs.role_arn }}" ]; then
            ROLE_ARN="${{ steps.lambda-config.outputs.role_arn }}"
          elif [ -n "${{ secrets.LAMBDA_EXECUTION_ROLE_ARN }}" ]; then
            ROLE_ARN="${{ secrets.LAMBDA_EXECUTION_ROLE_ARN }}"
          elif [ -n "${{ secrets.AWS_ROLE_ARN }}" ]; then
            ROLE_ARN="${{ secrets.AWS_ROLE_ARN }}"
          else
            echo "::error::No Lambda execution role ARN found. Set role_arn in lambda-config.yaml or LAMBDA_EXECUTION_ROLE_ARN secret."
            exit 1
          fi
          echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
          echo "Using Lambda execution role: $ROLE_ARN"

      - name: Deploy Lambda (image)
        uses: aws-actions/aws-lambda-deploy@v1.1.0
        with:
          # TODO: remove the environment from the function name after testing
          function-name: "${{ steps.lambda-config.outputs.function_name }}-${{ inputs.environment }}"
          package-type: Image
          image-uri: ${{ steps.image-uri.outputs.uri }}
          # Lambda execution role ARN (must be a role that Lambda service can assume)
          role: ${{ steps.lambda-role.outputs.role_arn }}
          function-description: ${{ steps.lambda-config.outputs.description }}
          timeout: ${{ steps.lambda-config.outputs.timeout }}
          memory-size: ${{ steps.lambda-config.outputs.memory_size }}
          ephemeral-storage: ${{ steps.lambda-config.outputs.ephemeral_storage }}
          architectures: ${{ steps.lambda-config.outputs.architectures }}
          environment: ${{ steps.lambda-config.outputs.env_vars }}
          vpc-config: ${{ steps.lambda-config.outputs.vpc_config }}
          dead-letter-config: ${{ steps.lambda-config.outputs.dead_letter_config }}
          kms-key-arn: ${{ steps.lambda-config.outputs.kms_key_arn }}
          tracing-config: ${{ steps.lambda-config.outputs.tracing_config }}
          file-system-configs: ${{ steps.lambda-config.outputs.file_system_configs }}
          image-config: ${{ steps.lambda-config.outputs.image_config }}
          snap-start: ${{ steps.lambda-config.outputs.snap_start }}
          logging-config: ${{ steps.lambda-config.outputs.logging_config }}
          code-signing-config-arn: ${{ steps.lambda-config.outputs.code_signing_config_arn }}
          publish: ${{ steps.lambda-config.outputs.publish }}
          tags: ${{ steps.tags.outputs.tags }}
